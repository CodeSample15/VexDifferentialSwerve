{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\nmotor motor1 = motor(PORT11, false);\nmotor motor2 = motor(PORT12, false);\ncontroller Controller = controller();\nmotor motor3 = motor(PORT5, false);\nmotor motor4 = motor(PORT6, false);\nmotor motor5 = motor(PORT7, false);\nmotor motor6 = motor(PORT8, false);\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       Luke Crimi                                                  \n//    Created:      {date}                                                    \n//    Description:  They said it could be done... and it could. I'm just dumb                                                \n//                                                                            \n//----------------------------------------------------------------------------\n\n// Include the IQ Library\n#include \"iq_cpp.h\"\n#include <math.h>\n#include <algorithm>\n#include <cmath>\n\n// Allows for easier use of the VEX Library\nusing namespace vex;\n\nclass hub {\n  private:\n    motor* m1;\n    motor* m2;\n\n    float HALF_ROTATION_OFFSET;\n\n    float targetRot;\n    float currentRot;\n    float driveSpeed;\n\n    float preverror1;\n    float preverror2;\n\n    bool reversed;\n    bool reversedAngle;\n\n    float normalizeAngle(float a) {\n      a += (180 * (int)(a / 180));\n      return a;\n    }\n\n    float optimize(float val) {\n      float travelDist = std::abs(val - hub::currentRot);\n\n      return val;\n    }\n\n  public:\n    //constructor\n    hub(motor& m1, motor& m2) {\n      hub::m1 = &m1;\n      hub::m2 = &m2;\n\n      HALF_ROTATION_OFFSET = 370;\n\n      m1.setPosition(0, degrees);\n      m2.setPosition(0, degrees);\n\n      targetRot = 0;\n      currentRot = 0;\n      driveSpeed = 0;\n\n      preverror1 = 0;\n      preverror2 = 0;\n\n      reversed = false;\n      reversedAngle = false;\n    }\n\n    //movement functions\n    void spinTo(float rot) {\n      hub::targetRot = rot;\n    }\n\n    void setSpeed(float speed) {\n      hub::driveSpeed = speed;\n    }\n\n    float pid(float error, bool ism1) {\n      //deadzone\n      if(error < 3)\n        return 0;\n\n      float p = error * 0.6; //kp\n      float d = 0;\n      \n      if(ism1) \n        d = (error - hub::preverror1);\n      else\n        d = (error - hub::preverror2);\n\n\n      d *= 0.33; //kd\n\n      if(ism1)\n        hub::preverror1 = error;\n      else\n        hub::preverror2 = error;\n\n      return p+d;\n    }\n\n    void update() {\n      //get the motors stored in the memory addresses recorded by the hub pointers\n      motor temp1 = *hub::m1;\n      motor temp2 = *hub::m2;\n\n      //370 is the distance the two motors have to be apart, encoder wise, for the wheel to be facing 180 degrees from its starting position\n      float offset = hub::HALF_ROTATION_OFFSET * (targetRot/180);\n      offset = hub::optimize(offset);\n\n      float target1 = hub::pid((temp2.position(degrees)-temp1.position(degrees)+offset), true);\n      float target2 = hub::pid((temp1.position(degrees)-temp2.position(degrees)-offset), false);\n\n      hub::currentRot = temp2.position(degrees)-temp1.position(degrees);\n\n      //if one motor is already spinning it's max speed and can't spin any faster to fix an error, slow down the other motor to compensate\n      float speed = hub::reversed ? -hub::driveSpeed : hub::driveSpeed;\n\n      if(std::abs(speed-target1) > 100 && std::abs(speed-target2) > 100) {\n        float maxCorrection = std::max(std::abs(target1), std::abs(target2)) - 100;\n\n        if(speed > 0)\n          speed -= maxCorrection;\n        else\n          speed += maxCorrection;\n      }\n      //the code above helps regulate the target code. If none of the wheels can adjust their speed in order to prevent wheel drive, simply slow down the bot to allow the motors to self correct\n\n      temp1.setVelocity(speed - target1, percent);\n      temp2.setVelocity(speed - target2, percent);\n\n      temp1.spin(reverse);\n      temp2.spin(reverse);\n    }\n};\n\nvoid debug() {\n  while (true) {\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.print(\"Angle: %f\", atan2(Controller.AxisA.position(), Controller.AxisB.position()));\n\n    Brain.Screen.setCursor(2,1);\n    Brain.Screen.print(\"Motor2: %f\", motor2.position(degrees));\n    \n    wait(10, msec);\n\n    Brain.Screen.clearScreen();\n  }\n}\n\n\nint main() {\n  thread t(debug);\n\n  hub fronth(motor2, motor1);\n  hub righth(motor4, motor3);\n  hub lefth(motor5, motor6);\n\n  while(true) {\n    float x = -Controller.AxisB.position();\n    float y = Controller.AxisA.position();\n    float speed = sqrt((x*x) + (y*y));\n\n    float rot = atan2(x,y);\n    rot = (rot / 3.14159) * 180;\n\n    float turnVal = Controller.AxisC.position();\n\n    if(speed < 10) {\n      rot = 0; //deadzone\n      speed = 0;\n    }\n    else {\n      fronth.spinTo(rot);\n      righth.spinTo(rot);\n      lefth.spinTo(rot);\n    }\n\n    fronth.setSpeed(speed);\n    righth.setSpeed(speed);\n    lefth.setSpeed(speed);\n\n    //fronth.update();\n    righth.update();\n    //lefth.update();\n\n    wait(15, msec);\n  }\n}\n","textLanguage":"cpp","rconfig":[{"port":[11],"name":"motor1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"motor2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[5],"name":"motor3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"motor4","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[7],"name":"motor5","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[8],"name":"motor6","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}