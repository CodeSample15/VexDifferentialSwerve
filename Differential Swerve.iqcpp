{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\nmotor motor1 = motor(PORT11, false);\nmotor motor2 = motor(PORT12, false);\ncontroller Controller = controller();\nmotor motor3 = motor(PORT5, false);\nmotor motor4 = motor(PORT6, false);\nmotor motor5 = motor(PORT7, false);\nmotor motor6 = motor(PORT8, false);\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       Luke Crimi                                                  \n//    Released:     TBD                                                    \n//    Description:  Differential Swerve Drive for a vex IQ bot                                         \n//                                                                            \n//----------------------------------------------------------------------------\n\n#include \"iq_cpp.h\"\n#include <math.h>\n#include <algorithm>\n#include <cmath>\n\n#define PI 3.14159\n\nusing namespace vex;\n\nclass hub {\n  private:\n    motor* m1;\n    motor* m2;\n\n    float HALF_ROTATION_OFFSET;\n\n    float targetRot;\n    float currentRot;\n    float driveSpeed;\n\n    float preverror1;\n    float preverror2;\n\n    bool reversed;\n\n    int overRotations;\n\n    float normalizeAngle(float a) {\n      a += (180 * (int)(a / 180));\n      return a;\n    }\n\n  public:\n    //constructor\n    hub(motor& m1, motor& m2) {\n      hub::m1 = &m1;\n      hub::m2 = &m2;\n\n      HALF_ROTATION_OFFSET = 360;\n\n      m1.setPosition(0, degrees);\n      m2.setPosition(0, degrees);\n\n      targetRot = 0;\n      currentRot = 0;\n      driveSpeed = 0;\n\n      preverror1 = 0;\n      preverror2 = 0;\n\n      overRotations = 0;\n\n      reversed = false;\n    }\n\n    //movement functions\n    void spinTo(float rot) {\n      float rotations = 360 * hub::overRotations;\n\n      //allow for the wheel to spin over the negative/positive line\n      if(std::abs((rot+rotations) - hub::currentRot) < 180)\n        hub::targetRot = rot + rotations;\n      else {\n        //check to see if coterminal angle has less travel distance\n        if(std::abs((rot+rotations+360) - hub::currentRot) < 180) {\n          hub::targetRot = rot+rotations;\n          hub::overRotations++;\n        }\n        else {\n          hub::targetRot = rot-rotations;\n          hub::overRotations--;\n        }\n      }\n\n      //optimize the wheel's path by reversing the motors if necessary\n      if(std::abs(hub::targetRot-hub::currentRot) > 90) {\n        //find the smallest absolute distance to rotate from three different routes\n        float shortest = std::min({std::abs(hub::targetRot-hub::currentRot), std::abs(hub::targetRot+180-hub::currentRot), std::abs(hub::targetRot-180-hub::currentRot)});\n\n        if(shortest == std::abs(hub::targetRot-hub::currentRot)) {\n          if(hub::reversed) {\n            //reset pid\n            hub::preverror1=0;\n            hub::preverror2=0;\n          }\n\n          hub::reversed = false; //I don't know if this is really necessary since the if statement before this one makes it unlikely this will run, but it's here just in case\n        }\n        else if(shortest == std::abs(hub::targetRot+180-hub::currentRot)) {\n          if(!hub::reversed) {\n            //reset pid\n            hub::preverror1=0;\n            hub::preverror2=0;\n          }\n\n          hub::reversed = true;\n          hub::targetRot = hub::targetRot+180;\n        }\n        else if(shortest == std::abs(hub::targetRot-180-hub::currentRot)) {\n          if(!hub::reversed) {\n            //reset pid\n            hub::preverror1=0;\n            hub::preverror2=0;\n          }\n\n          hub::reversed = true;\n          hub::targetRot = hub::targetRot-180;\n        }\n      }\n      else {\n        if(hub::reversed) {\n          //reset pid\n          hub::preverror1=0;\n          hub::preverror2=0;\n        }\n\n        hub::reversed = false;\n      }\n    }\n\n    void setSpeed(float speed) {\n      hub::driveSpeed = speed;\n    }\n\n    float pid(float error, bool ism1) {\n      //deadzone\n      if(error < 3)\n        return 0;\n\n      float p = error * 0.6; //kp\n      float d = 0;\n      \n      if(ism1) \n        d = (error - hub::preverror1);\n      else\n        d = (error - hub::preverror2);\n\n      d *= 0.33; //kd\n\n      if(ism1)\n        hub::preverror1 = error;\n      else\n        hub::preverror2 = error;\n\n      return p+d;\n    }\n\n    void update() {\n      //get the motors stored in the memory addresses recorded by the hub pointers\n      motor temp1 = *hub::m1;\n      motor temp2 = *hub::m2;\n\n      //370 is the distance the two motors have to be apart, encoder wise, for the wheel to be facing 180 degrees from its starting position\n      float offset = hub::HALF_ROTATION_OFFSET * (targetRot/180);\n\n      float target1 = hub::pid((temp2.position(degrees)-temp1.position(degrees)+offset), true);\n      float target2 = hub::pid((temp1.position(degrees)-temp2.position(degrees)-offset), false);\n\n      if(hub::reversed) {\n        float temp = target1;\n        target1 = target2;\n        target2 = temp;\n      }\n\n      hub::currentRot = ((temp1.position(degrees)-temp2.position(degrees))/hub::HALF_ROTATION_OFFSET) * 180;\n\n      //if one motor is already spinning it's max speed and can't spin any faster to fix an error, slow down the other motor to compensate\n      float speed = hub::driveSpeed;\n\n      if(std::abs(speed-target1) > 100 && std::abs(speed-target2) > 100) {\n        float maxCorrection = std::max(std::abs(target1), std::abs(target2)) - 100;\n\n        if(!hub::reversed)\n          speed -= maxCorrection;\n        else\n          speed += maxCorrection;\n      }\n\n      //the code above helps regulate the target code. If none of the wheels can adjust their speed in order to prevent wheel drive, simply slow down the bot to allow the motors to self correct\n\n      if(!hub::reversed) {\n        temp1.setVelocity(speed - target1, percent);\n        temp2.setVelocity(speed - target2, percent);\n\n        temp1.spin(reverse);\n        temp2.spin(reverse);\n      }\n      else {\n        temp1.setVelocity(-speed + target1, percent);\n        temp2.setVelocity(-speed + target2, percent);\n\n        temp1.spin(reverse);\n        temp2.spin(reverse);\n      }\n    }\n\n    void stop() {\n      motor temp1 = *hub::m1;\n      motor temp2 = *hub::m2;\n\n      //reset PID\n      hub::preverror1 = 0;\n      hub::preverror2 = 0;\n\n      //reset angle and offset of motor encoders\n      float normRot = hub::normalizeAngle(hub::currentRot);\n      temp1.setPosition(normRot/2, degrees);\n      temp2.setPosition(-normRot/2, degrees);\n\n      temp1.setVelocity(0, percent);\n      temp2.setVelocity(0, percent);\n\n      temp1.spin(forward);\n      temp2.spin(forward);\n    }\n};\n\nfloat getPolarX(float theta, float magnitude) {\n  //convert angle from degrees to radians to polar x coordinate\n  theta = (theta*PI)/180;\n  return magnitude * cos(theta);\n}\n\nfloat getPolarY(float theta, float magnitude) {\n  //convert angle from degrees to radians to polar y coordinate\n  theta = (theta*PI)/180;\n  return magnitude * sin(theta);\n}\n\n//takes a polar coordinate and converts it to radians and then degrees\nfloat getAngle(float x, float y) {\n  float a = atan2(y, x);\n  return (a / PI) * 180;\n}\n\nvoid normalizeVector(float& x, float& y) {\n  float m = sqrt((x*x)+(y*y));\n  x/=m;\n  y/=m;\n}\n\nfloat combineRotations(float driveRot, float driveSpeed, float turnRot, float turnSpeed) {\n  float drivePX = getPolarX(driveRot, driveSpeed);\n  float drivePY = getPolarY(driveRot, driveSpeed);\n\n  float turnPX = getPolarX(turnRot, turnSpeed);\n  float turnPY = getPolarY(turnRot, turnSpeed);\n\n  float togetherX = drivePX + turnPX;\n  float togetherY = drivePY + turnPY;\n\n  normalizeVector(togetherX, togetherY);\n  return getAngle(togetherX, togetherY);\n}\n\nvoid debug() {\n  while (true) {\n    float x = -Controller.AxisB.position();\n    float y = Controller.AxisA.position();\n    float speed = sqrt((x*x) + (y*y));\n\n    float rot = atan2(x,y);\n    rot = (rot / PI) * 180;\n\n    float turnVal = Controller.AxisC.position();\n\n    float frontRot = combineRotations(rot, speed, (90*turnVal/100), std::abs(turnVal));\n    frontRot=(float)round(frontRot);\n    rot = (float)round(rot);\n\n    Brain.Screen.setCursor(1,1);\n\n    if(frontRot!=rot) {\n      Brain.Screen.print(\"Problem!\");\n      Brain.Screen.setCursor(2,1);\n      Brain.Screen.print(\"rot: %f\", rot);\n      Brain.Screen.setCursor(3,1);\n      Brain.Screen.print(\"front: %f\", frontRot);\n      Brain.Screen.setCursor(4,1);\n      Brain.Screen.print(\"diff: %f\", frontRot-rot);\n    }\n    else {\n      Brain.Screen.print(\"rot: %f\", rot);\n      Brain.Screen.setCursor(2,1);\n      Brain.Screen.print(\"front: %f\", frontRot);\n      Brain.Screen.setCursor(3,1);\n      Brain.Screen.print(\"diff: %f\", frontRot-rot);\n    }\n\n    wait(20, msec);\n\n    Brain.Screen.clearScreen();\n  }\n}\n\nint main() {\n  thread t(debug);\n\n  hub fronth(motor2, motor1);\n  hub righth(motor4, motor3);\n  hub lefth(motor5, motor6);\n\n  while(true) {\n    float x = -Controller.AxisB.position();\n    float y = Controller.AxisA.position();\n    float speed = sqrt((x*x) + (y*y));\n\n    float rot = atan2(x,y);\n    rot = (rot / PI) * 180;\n    rot = (float)round(rot);\n\n    float turnVal = -(float)Controller.AxisC.position();\n\n    float frontRot = combineRotations(rot, speed, (90*turnVal/100), std::abs(turnVal));\n    float rightRot = combineRotations(rot, speed, ((turnVal>0? -30 : 120)*std::abs(turnVal)/100), std::abs(turnVal));\n    float leftRot = combineRotations(rot, speed, ((turnVal>0 ? -120 : 30)*std::abs(turnVal)/100), std::abs(turnVal));\n\n    frontRot = (float)round(frontRot);\n    rightRot = (float)round(rightRot);\n    leftRot = (float)round(leftRot);\n\n    //deadzone\n    if(speed > 7 || std::abs(turnVal) > 7) {\n      fronth.spinTo(frontRot);\n      righth.spinTo(rightRot);\n      lefth.spinTo(leftRot);\n\n      fronth.setSpeed(speed+std::abs(turnVal));\n      righth.setSpeed(speed+std::abs(turnVal));\n      lefth.setSpeed(speed+std::abs(turnVal));\n\n      fronth.update();\n      righth.update();\n      lefth.update();\n    }\n    else {\n      fronth.stop();\n      righth.stop();\n      lefth.stop();\n    }\n\n    wait(20, msec);\n  }\n}","textLanguage":"cpp","rconfig":[{"port":[11],"name":"motor1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"motor2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[5],"name":"motor3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"motor4","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[7],"name":"motor5","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[8],"name":"motor6","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}