{"mode":"Text","textContent":"#pragma region VEXcode Generated Robot Configuration\n// Make sure all required headers are included.\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n#include <string.h>\n\n\n#include \"vex.h\"\n\nusing namespace vex;\n\n// Brain should be defined by default\nbrain Brain;\n\n\n// START IQ MACROS\n#define waitUntil(condition)                                                   \\\n  do {                                                                         \\\n    wait(5, msec);                                                             \\\n  } while (!(condition))\n\n#define repeat(iterations)                                                     \\\n  for (int iterator = 0; iterator < iterations; iterator++)\n// END IQ MACROS\n\n\n// Robot configuration code.\nmotor motor1 = motor(PORT11, false);\nmotor motor2 = motor(PORT12, false);\ncontroller Controller = controller();\nmotor motor3 = motor(PORT5, false);\nmotor motor4 = motor(PORT6, false);\nmotor motor5 = motor(PORT7, false);\nmotor motor6 = motor(PORT8, false);\n\n\n\n// define variable for remote controller enable/disable\nbool RemoteControlCodeEnabled = true;\n#pragma endregion VEXcode Generated Robot Configuration\n\n//----------------------------------------------------------------------------\n//                                                                            \n//    Module:       main.cpp                                                  \n//    Author:       Luke Crimi                                                  \n//    Released:     TBD                                                    \n//    Description:  Differential Swerve Drive for a vex IQ bot. Never thought I'd type that sentence.                                            \n//                                                                            \n//----------------------------------------------------------------------------\n\n#include \"iq_cpp.h\"\n#include <math.h>\n#include <algorithm>\n#include <cmath>\n\nusing namespace vex;\n\nclass hub {\n  private:\n    motor* m1;\n    motor* m2;\n\n    float HALF_ROTATION_OFFSET;\n\n    float targetRot;\n    float currentRot;\n    float driveSpeed;\n\n    float preverror1;\n    float preverror2;\n\n    bool reversed;\n\n    int overRotations;\n\n    float normalizeAngle(float a) {\n      a += (180 * (int)(a / 180));\n      return a;\n    }\n\n  public:\n    //constructor\n    hub(motor& m1, motor& m2) {\n      hub::m1 = &m1;\n      hub::m2 = &m2;\n\n      HALF_ROTATION_OFFSET = 370;\n\n      m1.setPosition(0, degrees);\n      m2.setPosition(0, degrees);\n\n      targetRot = 0;\n      currentRot = 0;\n      driveSpeed = 0;\n\n      preverror1 = 0;\n      preverror2 = 0;\n\n      overRotations = 0;\n\n      reversed = false;\n    }\n\n    //movement functions\n    void spinTo(float rot) {\n      float rotations = 360 * hub::overRotations;\n\n      //allow for the wheel to spin over the negative/positive line\n      if(std::abs((rot+rotations) - hub::currentRot) < 180)\n        hub::targetRot = rot + rotations;\n      else {\n        //check to see if coterminal angle has less travel distance\n        if(std::abs((rot+rotations+360) - hub::currentRot) < 180) {\n          hub::targetRot = rot+rotations;\n          hub::overRotations++;\n        }\n        else {\n          hub::targetRot = rot-rotations;\n          hub::overRotations--;\n        }\n      }\n\n      //optimize the wheel's path by reversing the motors if necessary\n      if(std::abs(hub::targetRot-hub::currentRot) > 90) {\n        //find the smallest absolute distance to rotate from three different routes\n        float shortest = std::min({std::abs(hub::targetRot-hub::currentRot), std::abs(hub::targetRot+180-hub::currentRot), std::abs(hub::targetRot-180-hub::currentRot)});\n\n        if(shortest == std::abs(hub::targetRot-hub::currentRot)) {\n          hub::reversed = false;\n        }\n        else if(shortest == std::abs(hub::targetRot+180-hub::currentRot)) {\n          hub::reversed = true;\n          hub::targetRot = hub::targetRot+180;\n        }\n        else if(shortest == std::abs(hub::targetRot-180-hub::currentRot)) {\n          hub::reversed = true;\n          hub::targetRot = hub::targetRot-180;\n        }\n      }\n      else {\n        hub::reversed = false;\n      }\n    }\n\n    void setSpeed(float speed) {\n      hub::driveSpeed = speed;\n    }\n\n    float pid(float error, bool ism1) {\n      //deadzone\n      if(error < 3)\n        return 0;\n\n      float p = error * 0.6; //kp\n      float d = 0;\n      \n      if(ism1) \n        d = (error - hub::preverror1);\n      else\n        d = (error - hub::preverror2);\n\n      d *= 0.33; //kd\n\n      if(ism1)\n        hub::preverror1 = error;\n      else\n        hub::preverror2 = error;\n\n      return p+d;\n    }\n\n    void update() {\n      //get the motors stored in the memory addresses recorded by the hub pointers\n      motor temp1 = *hub::m1;\n      motor temp2 = *hub::m2;\n\n      //370 is the distance the two motors have to be apart, encoder wise, for the wheel to be facing 180 degrees from its starting position\n      float offset = hub::HALF_ROTATION_OFFSET * (targetRot/180);\n\n      float target1 = hub::pid((temp2.position(degrees)-temp1.position(degrees)+offset), true);\n      float target2 = hub::pid((temp1.position(degrees)-temp2.position(degrees)-offset), false);\n\n      if(hub::reversed) {\n        float temp = target1;\n        target1 = target2;\n        target2 = temp;\n      }\n\n      hub::currentRot = ((temp1.position(degrees)-temp2.position(degrees))/hub::HALF_ROTATION_OFFSET) * 180;\n\n      //if one motor is already spinning it's max speed and can't spin any faster to fix an error, slow down the other motor to compensate\n      float speed = hub::reversed ? hub::driveSpeed : hub::driveSpeed;\n\n      if(std::abs(speed-target1) > 100 && std::abs(speed-target2) > 100) {\n        float maxCorrection = std::max(std::abs(target1), std::abs(target2)) - 100;\n\n        if(!hub::reversed)\n          speed -= maxCorrection;\n        else\n          speed += maxCorrection;\n      }\n\n      //the code above helps regulate the target code. If none of the wheels can adjust their speed in order to prevent wheel drive, simply slow down the bot to allow the motors to self correct\n\n      if(!hub::reversed) {\n        temp1.setVelocity(speed - target1, percent);\n        temp2.setVelocity(speed - target2, percent);\n\n        temp1.spin(reverse);\n        temp2.spin(reverse);\n      }\n      else {\n        temp1.setVelocity(-speed + target1, percent);\n        temp2.setVelocity(-speed + target2, percent);\n\n        temp1.spin(reverse);\n        temp2.spin(reverse);\n      }\n    }\n};\n\nvoid debug() {\n  while (true) {\n    Brain.Screen.setCursor(1,1);\n    Brain.Screen.print(\"Angle: %f\", atan2(Controller.AxisA.position(), Controller.AxisB.position()));\n\n    Brain.Screen.setCursor(2,1);\n    Brain.Screen.print(\"Reversed: %f\", 0.3);\n    \n    wait(10, msec);\n\n    Brain.Screen.clearScreen();\n  }\n}\n\n\nint main() {\n  thread t(debug);\n\n  hub fronth(motor2, motor1);\n  hub righth(motor4, motor3);\n  hub lefth(motor5, motor6);\n\n  while(true) {\n    float x = -Controller.AxisB.position();\n    float y = Controller.AxisA.position();\n    float speed = sqrt((x*x) + (y*y));\n\n    float rot = atan2(x,y);\n    rot = (rot / 3.14159) * 180;\n\n    float turnVal = Controller.AxisC.position();\n\n    if(speed < 10) {\n      rot = 0; //deadzone\n      speed = 0;\n    }\n    else {\n      fronth.spinTo(rot);\n      righth.spinTo(rot);\n      lefth.spinTo(rot);\n    }\n\n    fronth.setSpeed(speed);\n    righth.setSpeed(speed);\n    lefth.setSpeed(speed);\n\n    fronth.update();\n    righth.update();\n    lefth.update();\n\n    wait(15, msec);\n  }\n}\n","textLanguage":"cpp","rconfig":[{"port":[11],"name":"motor1","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[12],"name":"motor2","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[],"name":"Controller","customName":false,"deviceType":"Controller","deviceClass":"controller","setting":{"left":"","leftDir":"false","right":"","rightDir":"false","e":"","eDir":"false","f":"","fDir":"false","l3r3":"","l3r3Dir":"false","drive":"none"},"triportSourcePort":22},{"port":[5],"name":"motor3","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[6],"name":"motor4","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[7],"name":"motor5","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22},{"port":[8],"name":"motor6","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse"},"triportSourcePort":22}],"slot":0,"platform":"IQ","sdkVersion":"20220726.10.00.00","appVersion":"2.4.5","minVersion":"2.4.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","target":"Physical"}